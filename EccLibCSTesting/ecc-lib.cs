// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace EccLib
{
    public unsafe partial class Functions : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 0)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("ecc-lib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="??0Functions@EccLib@@QEAA@AEBV01@@Z")]
            internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ecc-lib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DummyEncode@Functions@EccLib@@SAXQEAE0@Z")]
            internal static extern void DummyEncode(byte[] data, byte[] encoded);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("ecc-lib", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="?DummyDecode@Functions@EccLib@@SAXQEAE0@Z")]
            internal static extern void DummyDecode(byte[] data, byte[] decoded);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EccLib.Functions> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::EccLib.Functions>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        internal static global::EccLib.Functions __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new global::EccLib.Functions(native.ToPointer(), skipVTables);
        }

        internal static global::EccLib.Functions __CreateInstance(global::EccLib.Functions.__Internal native, bool skipVTables = false)
        {
            return new global::EccLib.Functions(native, skipVTables);
        }

        private static void* __CopyValue(global::EccLib.Functions.__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(global::EccLib.Functions.__Internal));
            *(global::EccLib.Functions.__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Functions(global::EccLib.Functions.__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected Functions(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public Functions()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::EccLib.Functions.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public Functions(global::EccLib.Functions _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::EccLib.Functions.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::EccLib.Functions.__Internal*) __Instance) = *((global::EccLib.Functions.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            global::EccLib.Functions __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public static void DummyEncode(byte[] data, byte[] encoded)
        {
            if (data == null || data.Length != 20)
                throw new ArgumentOutOfRangeException("data", "The dimensions of the provided array don't match the required size.");
            if (encoded == null || encoded.Length != 20)
                throw new ArgumentOutOfRangeException("encoded", "The dimensions of the provided array don't match the required size.");
            __Internal.DummyEncode(data, encoded);
        }

        public static void DummyDecode(byte[] data, byte[] decoded)
        {
            if (data == null || data.Length != 20)
                throw new ArgumentOutOfRangeException("data", "The dimensions of the provided array don't match the required size.");
            if (decoded == null || decoded.Length != 20)
                throw new ArgumentOutOfRangeException("decoded", "The dimensions of the provided array don't match the required size.");
            __Internal.DummyDecode(data, decoded);
        }
    }
}
